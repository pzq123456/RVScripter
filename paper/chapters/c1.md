# 第一章 绪论
## 1.1 研究背景

## 1.2 国内外研究现状

### 1. 谷歌地球引擎：为每个人准备的多尺度地理空间数据分析平台
- 背景：随着超级计算机及高性能计算系统资源日益丰富，云计算服务的商品化也变得越来与普遍。与此同时，免费的多尺度遥感数据资源也随着世界范围内的政府机构数据开放，变得越来越丰富。然而，想要充分利用这些已有的资源，却需要相当可观的技术投入。这需要一个庞大的信息系统来统筹数据库管理、计算资源分配、网络管理以及众多地理数据处理框架适配。
- 本质及功能：谷歌地球引擎是一个高性能计算云端平台，集成了大量空间数据集及空间数据处理框架。这使得用户一定程度上摆脱了硬件及数据短缺的困扰。并且，用户还可以轻易共享基于谷歌地球引擎的算法。地球引擎本质上是一个支持高效处理 PB 级别的数据并行计算设施，它使用网络接口对外提供服务，并且用户可以在一个基于网络的交互式编程环境中快速构建算法原型并查看运行结果。谷歌地球引擎收录了众多公开地理数据集主要包括：众多遥感卫星及航空摄影系统的多波段遥感信息、气象参数、土地覆盖类型数据等。所有的这些数据都已经过预处理，可以在地球引擎内直接使用。
- 数据结构：谷歌地球引擎基于常见的多波段二维网格遥感数据设计了轻量化的影像数据容器类（类名为 image ）。在该容器类内，任意波段的二维格网数据都必须有相同的数据类型、分辨率以及投影。同时，该容器还需要支持键值对类型的元数据格式，如位置、数据集发布时间、预处理信息等。所有相互关联的影像（譬如同一传感器所生产的影像数据）构成影像集合类（类名为 collection）。影像集合类可以快速对相关数据进行检索，譬如用户可以按照时间及云量参数对 Landset 7 的传感器数据进行检索。
- 数据预处理：地球引擎会将原始数据直接裁剪为 256 * 256 的格网数据，有别于传统的“数据立方体”系统，地球引擎不会对数据进行重采样而是保留原有的投影、分辨率及比特深度。为了在用户进行在线脚本编写时，快速显示影像数据，系统需要提前构建多分辨率尺度的影像金字塔，该影像金字塔是在原始数据的基础上以二为底数进行降采样得到。（对于离散值，如分类标签数据等，系统会使用最小、模式、最大或固定采样之一进行采样。）这样加载了低分辨率的区域图像用于快速显示的同时，更高精度金字塔层级的影像数据也就得以被筛选并合理加载出来。
- 系统架构：谷歌地球引擎代码编辑器及其他基于此的第三方应用都是通过一个客户端软件包（由 JavaScript 或 Python 编写）与后台的 REST API 进行交互的。即时请求会首先被服务端前台处理，同时繁琐的子查询会由前台递交计算管理设施并分配到服务器池中。批处理系统也采用同样的数据处理规则，只不过是采用 FlumeJava 来管理任务分发。FlumeJava 是一个用于支撑开发并行数据处理管线的系统，使用 Java 语言编写。该系统针对并行计算所需的操作抽象出少量算子，并将这些算子进一步抽象为几个核心类。谷歌地球引擎提供超过 800 个函数，大致包括：纯数学运算操作、强大的地理统计操作、机器学习以及影像处理等。用户可以将这些函数组合成自己想要的查询语句，并借助于平台的可视化、数据打印导出等功能来评估结果。
- 计算功能：针对遥感影像，系统提供逐像元、逐波段及波段间的基础代数运算，支持整型、浮点型、数组型、字典型及布尔型等多种数据类型。同时，系统还整合了其他已有的函数库，提供多达20中监督分类、回归算法、非监督分类及用于精度评估的混淆矩阵。用户可以使用上述的功能函数来表达他们想要完成的空间数据计算任务，这种计算任务本质上是一种有向无环图（DAG），图中每一个节点表示一种数据处理函数或数据输入函数（用键值对来表示）。本质上，这是一种纯函数式的编程环境，针对这种特性，谷歌地球引擎也做了许多优化，如透明引用及懒计算等。用户使用兼容客户端语言的客户端程序包提供的函数来编写算法脚本，这样可以大大减少用户的学习成本。本质上，客户端程序包实现了后台众多 REST 接口的代理对象，用户操纵这些代理对象来达成想要的功能。同时，客户端程序包还负责解析用户脚本，生成描述了对应脚本的 DAG 图，并将描述了该 DAG 图的数据结构发送到后端。当然，客户端程序包针对 DAG 图的解析也做了许多优化，譬如合并冗余的节点，直接在客户端完成简单的计算任务（如数值计算，某节点需要计算 3 + 7，在客户端就会直接使用计算结果 10 替换原节点）。
- 懒计算模型：为了实现快速、交互式、可缩放的空间数据分析，谷歌地球引擎使用懒计算模型，即仅加载并计算当前区域的数据。通过检测用户地图缩放等级、投影状况、视窗位置等参数，谷歌地球引擎能动态调整计算的详尽横渡。譬如，某一计算结果所表示的像素点在当前视窗或缩放级别下不可见，则系统会忽略该计算。设计这一套机制的目的是尽可能快地将分析结果呈现给用户，同时尽量减少计算资源的浪费。


### 2. 微软必应地图的瓦片地图系统架构
- 概述：微软必应地图（Bing Map）是一款交互式、世界范围的电子地图。该项目为了尽可能快速地响应用户，预渲染了不同缩放层级下的地图并使用瓦片地图系统（Bing Map Tile System）来管理这些预渲染地图。通过研究该系统的架构，我们可以深入了解现代互联网瓦片地图的工作原理，包括地图投影、坐标系系统以及瓦片映射寻址策略等。
- 地图投影：为了确保地图显示的视觉效果，需要一种足够简单高效的地图投影来处理世界范围的地理数据。必应地图采用墨卡托投影，一种简单的保角的圆柱投影。考虑到墨卡托投影极地区的投影会趋向于无穷，所以将最大可投影纬度限制在正负 85.05 以内。同时，为了进一步简化计算，采用球形墨卡托投影的计算公式来计算，这样做会造成Y方向上约0.33%的，几乎肉眼不可见的比例失真。通过上述操作，我们就得到了经典的 Web 墨卡托投影（识别码：EPSG:3857 ，早些时候为 EPSG:900913）数学公式：
  $$ x = R * \frac{\pi}{180} * \lambda $$
  $$ y = R * \frac{\pi}{180} * \ln(\tan(\frac{\pi}{4} + \frac{\phi}{2})) $$
  - 其中 $R$ 为地球半径，$\lambda$ 为经度，$\phi$ 为纬度。
  > - 对于 y 的计算函数，我们可以进一步简化为：
  > $$ y = \frac{R}{2} * \ln(\frac{1+\sin(\phi')}{1-\sin(\phi')}) $$
  > $$ \phi' = \frac{\pi}{180} * \phi  $$

  LeafLet 中的代码实现(y 的计算参照公式二)如下：
  ```ts
  project(latlng: LatLng) : Point {
    const d = Math.PI / 180,
        max = this.MAX_LATITUDE,
        lat = Math.max(Math.min(max, latlng.lat), -max),
        sin = Math.sin(lat * d);

    return new Point(
      this.R * latlng.lng * d,
      this.R * Math.log((1 + sin) / (1 - sin)) / 2);
  }

  unproject(point: Point) : LatLng {
    const d = 180 / Math.PI;

    return new LatLng(
      (2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
      point.x * d / this.R);
  }
  ```
- 地图缩放比率（Map Scale）及地面分辨率（Ground Resolution）：在渲染地图时，除了需要指定特定的投影方式，还需要指定特定的地图缩放比率。在最低层级（Level 1），所显示世界地图总共只有 512 * 512 个像素。可以使用如下公式来计算对应层级下的地图渲染尺寸（假设一个瓦片的尺寸始终为 256 * 256 像素）：
  $$ width = height = 256 * 2^z $$
  - 其中 $z$ 为地图缩放层级。
  - 单位为像素。
地面分辨率指的是图中一个像素所代表的实际地面距离。例如，地面分辨率 10m/pixel 代表的是地图上每一个像素相当于地面上10米的距离。地面分辨率随着纬度、缩放层级及设定的地球半径而变化需要根据实际情况动态量测。
- 像素坐标系：在确定了投影方式和缩放尺寸后，我们就可以将地理坐标系下表示的事物投影到用于显示和交互的像素坐标系中。在必应地图中，像素坐标系采用与屏幕坐标系同样的规则，即左上角为坐标系原点 (0,0) ，x 轴向右延伸，y 轴向左延伸。计算公式如下：
$$ pixelX = \frac{(\lambda + 180)}{360} * 256 * 2^{\text{level}} $$
$$ pixelY = (0.5 – \frac{\ln((1 + \phi'') / (1 – \phi''))}{4 \pi}) * 256 * 2^{\text{level}} $$
$$ \phi'' = \sin(\frac{\pi}{180} * \phi) $$
- 瓦片坐标及四进制键编码系统（Quadkeys）：为了优化地图瓦片的存取性能，预渲染地图瓦片统一大小为 256 * 256，并且随着缩放级别的增加瓦片数量也呈以二为底数指数递增。对于某一特定级别，世界地图上的每一地图瓦片都有自己的二维（XY）编号，譬如左上角的瓦片为 (0,0) 右下角的瓦片编号为 ($2^{level} - 1$, $2^{level} - 1$ )，根据上述规则，可以很容易由屏幕坐标系下的坐标计算出当前像素所处的地图瓦片编号(除以瓦片尺寸再取整即可)。为了优化构建索引存储地图瓦片所消耗的内存，将二维瓦片编码整合进一维字符串：四进制键编码（Quadkeys），每一个四进制键编码唯一表示了某一特定缩放级别下的地图瓦片，该编码可以用作通用数据库中B树索引的键值。具体操作步骤为：
  1. 二进制表示：将某一地图瓦片的坐标编码（X，Y）分别转化为对应的二进制表示；
  2. 交叉位存储编码：将二进制表示的两个坐标按照由高位到底位，先Y后X交叉为新的二进制结果Key；
  3. 解码：以保留高位零的四进制数编码读取结果Key，转化为字符串；
该编码方式得到的四进制键具有如下特性：
  1. 编码的字符串长度就是当前缩放层级；
  2. 继承性：当前编码字符串的高位对应父地图瓦片的编码；
  3. XY空间中的邻接特征也得以保留：XY坐标相近的四进制键编码也相近；
## 1.3 论文主要研究内容

本课题计划针对现代浏览器的诸多技术特性，使用 TypeScript 语言设计并实现一系列用于支撑地理信息系统核心功能的模块，这些核心模块可以快速构建地理信息系统的基础功能，包括基于 GeoJSON 标准的地理信息存取、地图显示、地理要素编辑、（简易）空间分析等。同时，本课题还计划设计并实现一个在线代码编辑器，用于支持用户在浏览器中编写、调试和运行地理数据分析处理脚本。本课题的研究目的和意义主要包括以下几个方面：

- 依托现代浏览器的诸多技术特性，开发与之相适应的地理信息系统核心功能模块，并研究一种异于桌面端地理信息系统的技术路线。
- 研究使用 TypeScript 语言实现地理信息系统的核心算法，如地理要素的投影、空间索引、空间分析等。在编码实践中，把控项目质量，使用单元测试、版本管理、持续集成等现代软件开发工具和方法，提高代码质量和开发效率。注重文档编写，搭建相应的文档网站，以便于用户和开发者使用和参与开发。
- 研究现有涉及地理信息的优秀开源项目（如 Turf.js、Leaflet、OpenLayers 等），学习其设计思路和实现方法，总结业界实践经验与默认标准。
- 面向专业用户，开发出一款好用的在线代码编辑器。用户基于上述基础设施，可以编写更为专业复杂的业务脚本，提高系统的易用性。

## 1.4 论文结构安排
